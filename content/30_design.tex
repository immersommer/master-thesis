\chapter{Design}
\label{sec:design}

% Ist das zentrale Kapitel der Arbeit. Hier werden das Ziel sowie die
% eigenen Ideen, Wertungen, Entwurfsentscheidungen vorgebracht. Es kann
% sich lohnen, verschiedene Möglichkeiten durchzuspielen und dann
% explizit zu begründen, warum man sich für eine bestimmte entschieden
% hat. Dieses Kapitel sollte - zumindest in Stichworten - schon bei den
% ersten Festlegungen eines Entwurfs skizziert werden.
% Es wird sich aber in einer normal verlaufenden
% Arbeit dauernd etwas daran ändern. Das Kapitel darf nicht zu
% detailliert werden, sonst langweilt sich der Leser. Es ist sehr
% wichtig, das richtige Abstraktionsniveau zu finden. Beim Verfassen
% sollte man auf die Wiederverwendbarkeit des Textes achten.

% Plant man eine Veröffentlichung aus der Arbeit zu machen, können von
% diesem Kapitel Teile genommen werden. Das Kapitel wird in der Regel
% wohl mindestens 8 Seiten haben, mehr als 20 können ein Hinweis darauf
% sein, daß das Abstraktionsniveau verfehlt wurde.

%\ldots design \ldots

%\todo{write design}

In this Chapter, we analyse the system call implementation and other IO methods that are used to perform communication between application and user. Then, based on the various deficiencies of the above methods, we will propose a novel mechanism, which is aim to improve the IO performance and secure the isolation between applications and devices.

\section{Kernel Offloading}
Let us review the implementation of the system call first. As shown in figure x, the application must enter the kernel to interact with devices with the help of systen call.  Due to security issues, OS exploits ring protection to isolate applications and devices since applications are not trustworthy. With the continuous improvement of performance requirements for data exchange in the Internet era, this mechanism is becoming more and more outdated in the context of requirements for IO performance. The main reason comes from the privilege transition and its side effect, as we mentioned above. In particular, the networking stack in the kernel is designed for compatibility of variant network protocol instead of high performance communication. Therefore the speed of IO paths through the kernel is slow.

How to address this issue？ The most straightforward answer is kernel bypass. Kernel bypass allows applications directly communicate with devices by mapping the device IO into userspace. Because the communication bypassed the kernel, severe performance penalty caused by the kernel is dropped. The application could manipulate device IO register similar to accessing userspace memory. In addition, by configuring device IO registers data can be transferred directly between application and device using DMA, instead of copying it first to the kernel and then to userspace.

In summary, Mapping device IO to userspace has two advantages. The first is that the performance is increased dramatically by avoiding privilege transitions. Secondly, multiple copies between applications and devices can be avoided. Hence, we would like to map the device IOs to user space in our fast call mechanism too.

\section{Isolation Between User And Device}

\begin{figure}[tbp]
  \centering
  \includegraphics[width=0.8\textwidth]{images/fastcall__design_idea}
  \caption[Short description]{Fastcall Design Idea}
  \label{fig:fastcall__design_idea}
\end{figure}


Directly mapping device IOs to user space is faster for communication between 
applications and devices. On the other hand, it could be a disaster in terms of 
security. Imagine that if the user knows where the device is, the user can manipulate 
the device intentionally or unintentionally, leading to a device crash. More serious is 
that the attacker can intercept other users' packages or send wrong packages to a user.  
Hence, we need isolation between application and device IOs in some degradation. Otherwise, 
userspace mapped IOs would be pointless. 


How to isolate the application and the device? Generally 
speaking, we use two methods. First, each address of the 
userspace device mapping IO should be random, and the application 
should not know its address. This method makes it difficult for applications 
to guess the address of the user space mapped device IOs. You may ask, If the
application does not know the address of the userspace mapped IO, how does it 
reach the device mapped IO and communicate with it? Our second method starts to use. 
As shown in Figure ~\ref{fig:fastcall__design_idea}, we place a stub between the application and the device IO, which contains the addresses of all the device IO memory that the application needs to know and code that define what the application can do on the device. In particular, this stub is only executable but not readable. Therefore, an application cannot either read device IOs addresses out of this stub or manipulate the device badly. It can only call the stub containing the userspace mapped IO address and let the stub complete the predefined operation on the device. 

In short, every fast call is composed of two parts: the only executable Stube and userspace mapped device IOs.By doing so, we could isolate devices from an untrustworthy application successfully. 

\section{Flexibility}

As we analyzed before, the system call is called by the SYSCALL instruction. Calling system calls may destroy the coexistence of the code because if applications want to call system calls, applications need to switch to assembly or implement wrapper functions. Compared with the system call, after the application has registered the fast call through IOCTL, it can directly call the fast call through the function pointer. We will discuss in detail the registration process of fast call in the following chapters. You only need to know that the application obtains the stub address of the quick call after completing the quick call registration. This is very flexible and easy to integrate into the user-level implementation.

\section{Overview}
\begin{figure}[tbp]
  \centering
  \includegraphics[width=0.8\textwidth]{images/Stub_partition}
  \caption[Short description]{Stub Partition}
  \label{fig:Stub_partition}
\end{figure}

Let us go a little bit dipper to the stub of a fast call. 
In order to facilitate understanding, we roughly mentioned 
that this stub is only executable. The truth is that This statement is partially right. 
The reason is that an application cannot invoke a fast call via function pointer if the memory 
region of this stub is only executable. In other words, the request of using function pointer 
is that the code called by function pointer is located on a readable and executable memory region.

On the other hand, we need the memory region of the stub only 
executable to prevent an attacker from reading the addresses of 
the device-mapped IOs. How to solve this Conflict？ The answer is 
simple: separate the stub into two parts,e.g., the fast call entry and the secret regions. 
As shown in the figure  ~\ref{fig:Stub_partition}, the fast call entry region contains the code predefined how to manipulate the device IOs and is mapped to an executable and readable memory region. The difference from the first part is that the second part containing the secret(addresses of device mapped IOs) is mapped to an executable memory region. Every time the code on the fast call entry region needs to operate on device mapped IOs. It needs first to retrieve the correspondent device mapped IOs's address from the secret region. 

\section{Overview}
\begin{figure}[tbp]
  \centering
  \includegraphics[width=0.8\textwidth]{images/fastcall_architecture}
  \caption[Short description]{Fastcall Architecture}
  \label{fig:fastcall_architecture}
\end{figure}



So far, we have learned multiple design decisions of fast call. Now let us take a look at the fast call mechanism complete picture. Each registered fast call is provided to each application as part of its userspace and runs at the same non-privileged level.

Figure ~\ref{fig:fastcall_architecture} illustrates the architecture of the fast system call mechanism in the current version. The core of each fast call is composed of 3 different memory regions. They are the fast call entry region, the fast call secret region, and the fast call hidden region(Device IOs mapped on user space). In order to distinguish between system calls and fast calls, these two mechanisms have a slightly different calling methods. In other words, instead of the system call being called by the instruction syscall, the fast call uses the function pointer along with the fast call entry memory address returned by the fast call registration function to call the fast call. All the components of a fast call run in the userspace. An application can therefore use fast calls like a typical function call.

The fast call entry area is the core of the new fast system call mechanism. This memory area is readable and executable, which makes it an ordinary text segment. The fast call entry routine mapped to this area assumes the responsibility of the service function in the system call mechanism, as shown in Figure X. This routine completes all predefined operations on device IOs mapped on userspace required by a fast call and returns the result to an application. Specifically, this routine verifies the parameters passed in by the program, obtains the address of the hidden area stored in the secret region, controls a particular device by manipulating its IO memories, and eliminates hidden address records before the routine return. The important thing is that if the routine does not retrieve the address of the device mapped memory (hidden region) from the secret region, it cannot communicate with the device.

The secret region, just like its name，contains addresses of the hidden region as secrets. The unique feature of this region is that the secret memory is only executable, such that any attempt to read the content of this region will cause an exception. With the feature, we protect the content in the secret region seen or copied by potential attackers.

The hidden region is Memory-mapped I/Os that represent the devices IO on userspace. With this region, a fast call could directly control the device without trapping the kernel into kernel space, making fast calls similar to regular function calls. To protect this region from attack or seen by an application, we randomize each hidden region of fast call during the fast call registration process. Thus, there is a high chance that only function on fast call entry region can access the hidden region.

In short, we introduced a new IO mechanism to solve the trouble os bypassing caused,  such as the lack of isolation between drivers and applications and the performance loss caused by privilege transitions during system calls. In the next section, we will have a deeper understanding of the implementation details of this new mechanism and how to register for fast calls.

\cleardoublepage

%%% Local Variables:
%%% TeX-master: "diplom"
%%% End:
